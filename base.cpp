#include <iostream>
#include <string.h>
using namespace std;
// 【黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难】 https://www.bilibili.com/video/BV1et411b73Z/?p=4&share_source=copy_web&vd_source=d858c6ae113d28a5ee3e69f10b5d3b41
// 1. C++定义常量两种方式
//    1.1 #define 宏常量： #define 常量名 常量值 通常在文件上方定义，表示一个常量
//    1.11#define 宏名(参数列表) 替换文本  注意下面的() 
          #define MAX(a, b) ((a) > (b) ? (a) : (b))
          #define SQUARE(x) ((x) * (x))
//    1.2 const修饰的变量 const 数据类型 常量名 = 常量值 通常在变量定义前加关键字const，修饰该变量为常量，不可修改
// 2. 数据类型
//    2.1 short(短整型)	2字节 int 4字节 long Windows为4字节，Linux为4字节(32位)，跟int好像没区别，long long 8字节
//    2.2 sizeof关键字 sizeof( 数据类型 / 变量)
//    2.3 float	    4字节	7位有效数字
//        double	8字节	15～16位有效数字
//        有效数字是指在一个数中，从该数的第一个非零数字起，直到末尾数字止的数字称为有效数字
//        浮点数默认都是 double类型  0.1f加f转为单精度类型
//    2.4 字符型char ch = 'a';用单引号将字符括起来，不要用双引号，只能有一个字符,字符型变量只占有1字节
//    2.5 转义字符用于表示不能显示出来的字符 \t \n \\等等
//    2.6 字符串，有两种风格
//        C     风格 char 变量名[] = "字符串值", 再次对字符串赋值就不能这样了 用字符串处理函数 strcpy();赋值超过初始化时的长度，奇怪的是mingw64可以通过编译，msys2不可以，网络搜索也不可以
//        C++   风格  string 变量名 = "字符串值" 注意要引入 #include <string.h>
//    2.7 布尔类型：bool类型只有两个值： 占用一个字节
//        true --- 真（本质是1）
//        false --- 假（本质是0）
//    2.8 一维数组
//        char buf[1024] = { 0 };数组初始化方式,每个元素都为0; 另一种写法效果等价  char buf[1024] = { };
//        数据类型 数组名[ 数组长度 ];
//        数据类型 数组名[ 数组长度 ] = { 值1，值2 ...};
//        数据类型 数组名[ ] = { 值1，值2 ...};
//        实践发现 (int)&arr[0] 会报错，int* 转 int 会丢失精度，sizeOf(&arr[0])发现是8字节，应该转成long long或者使用printf函数, uintptr_t 用于指针地址类型与整形转换
//    2.9 二维数组
//        数据类型 数组名[ 行数 ][ 列数 ];
//        数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };
//        数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};
//        数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4};
      
//--------以下内容来自网络----------
// 3. 变量初始化
// int i 声明int变量时不是必须要进行初始化的,如果变量未被初始化，它将包含一个未知的值，这可能会导致不可预测的行为,做好初始化
// 在C++11之后的标准中，引入了统一的初始化语法 int i{}; i值为0
// 4. 数组初始化
// char buf[1024] = {0};全初始化为 0 
// char buf[1024] = {1};第一个元素1 其余元素0
// 当使用 { } 初始化器初始化数组时：如果初始化列表中的元素个数少于数组大小，则剩余元素会被初始化为0（对于基本类型
// memset() 是 C/C++ 标准库中的一个内存操作函数（定义在 <string.h> 或 <cstring> 头文件中），主要用于 将一段内存区域的每个字节设置为特定值。
//c 标准库处理字符串的函数
// strcpy()  strncpy(dest, src, 5);  size_t len = strlen(str);  // 获取字符串的长度   未完待总结
//
// 1.1
/**'
 * ----------------------来自c++ primery--------------------
 * 4. 类型之间转换
 *  一部分例子 有符号和无符号之间的转换
 *  4.1 表达式包含无符号类型和有符号类型，有符号类型会转成无符号类型 例如 unsigned int a * int b 
 *  4.2 给无符号类型赋值超过范围的值，例如 unsigned char 截取该类型低8为；256二进制 1 0000 0000.低8为是0.
 *      更为简便的公式算法 256%(255+1)=0 c最大255 例如 unsigned char c = 256; c=0
 *  4.3 给无符号类型赋值负数，相当与有符号类型转换成无符号类型，二进制解释起来太麻烦，直接上公示 
 *      例如
 *      结果 = 有符号值 + k × (2ⁿ) n为该类型的位数
 *      其中 k 是满足 结果 ∈ [0, 2ⁿ-1] 的最小正整数
 *      例如 unsigned char c = -1; 结果 = -1 + 1 × (2^8) = 255
 * 4.4 字面值常量
 *     每个字面值常量对应一种数据类型。符号和值决定了它的类型。
 *     C++标准规定，字面值常量（整数和浮点数）都是非负的。如果你需要负值，你需要使用一元负号运算符。
 *     （-42 、-0XFF、-077） 是一个表达式，不是字面值常量 它由一元负号运算符 - 和字面值常量 42 组成
 *     4.4.1字符和字符串字面值 由单引号括起来的单个字符称为char型字面值，例如 'a' 字符串字面值实际上是常量字符构成的数组尾部用'/0'结尾
 *     4.4.2转义序列 一些打印不出来的字符例如 空格 \t 换行 \n 退格 \b 等等. 泛化转义序列 \后面紧跟8或者16进制数字表示字符例如 \7 \0 \xFF \115代表字符M
 *                  注意\后面的8进制数字智能有3位。\后面的16进制数不限制位数
 *     指定字面值类型 u 或 U：表示无符号整数（unsigned）l 或 L：表示长整数（long）ll 或 LL：表示长长整数（long long）
 *     42u 42l L'a' 42ll 0XFFu 0777l 不熟悉就搜索
 *     4.4.3 布尔类型字面值 true false 
 *     4.4.4 指针字面值 nullptr 代表空指针·
 * 5. 变量
 *    变量定义： 类型说明符 变量名 = 初始值 、类型说明符 变量名 、 类型说明符 变量名1,变量名2、型说明符 变量名1,变量名2=初始值
 *    初始化：当变量或者对象创建时获得一个特定值
 *    初始化列表：int x{4.2}; int x = 1.1; int x(0); 三种初始化方式 第一种类型转换存在丢失精度的风险，编译器会报错 .第二种正常转换并且丢失精度
 *    内置类型未被初始化，函数体外部默认初始化值0，函数体内部不被初始化
 *    一个程序被拆分成多个文件，c++支持分离式编译，c++将声明和定义区分开来。多个文件使用同一个变量怎么解决呢？使用extern关键字
 *    extern 用于声明变量或函数是在其他文件中定义的，告诉编译器这些符号在其他编译单元中存在，当前文件只是引用它们 
 *    变量可以被声明多次但只能定义一次
 *    extern int a; // 声明
 *    int a;        // 定义+声明
 *    标识符
 *    C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。
 *    C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。
 *    此外，定义在函数体外的标识符不能以下划线开头。
 *    5.1 变量作用域
 *        变量的作用域是指变量在程序中可见和可访问的范围门外层作用域声明的变量 在内层作用域中都能访问，允许内层作用域重新定义外层作用域的变量
 * 6. 符合类型
 *    C++有几种复合类型 引用和指针
 *    6.1 引用 类型名 &变量名 = 已有变量名; 相当与给变量取一个别名，引用必须初始化，引用一旦初始化后就不能再引用其他变量
 *        引用类型不能绑定字面值， 不能自动转换 例如 double b = 10; int &r = b; 这是错误的；引用不是对象所以引用不能绑定引用
 *    6.2 指针 类型名 *变量名; 指针是一个变量，存储另一个变量的地址，指针变量可以改变指向，指针不用在定义时初始化，但是未经初始化的指针使用时会报错，最好在定义时初始化
 *        指针不能指向其他类型的对象，编译报错。
 *        空指针不是未经初始化的指针而是不指向任何对象  int *p = nullptr; int *p = 0; int *p = NULL; 都表示空指针。c++对剑第一种；NULL 实际是 0
 *        6.2.1 void* 指针 是一种特殊的指针可以存放任意类型的地址  void *p;
 *        6.2.2 指针的指针 类型名 **变量名; 存储指针地址的指针 int a = 10; int *p = &a; int **pp = &p;
 *        6.2.3 指向指针的引用 类型名 *&变量名 = 已有指针变量名;int a = 10; int *p = &a; int *&r = p;
 *              引用不是对象所以不存在指向引用的指针
 *    6.3 const限定符 
 *        const可以修饰变量一旦创建后值不再改变，const修饰的变量必须初始化，有两种初始化方式
 *        运行时初始化 const int a = func();
 *        编译时初始化 const int b = 10;
 *        6.3.1 多个文件共享const变量 
 *       若const对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。
 *       若const对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时const变量的声明和定义前都应该添加extern关键字。 
 *       // file_1.cc defines and initializes a const that is accessible to other files
 *         extern const int bufSize = fcn();
 *      // file_1.h
 *        extern const int bufSize;   // same bufSize as defined in file_1.cc   
 *       6.3.2 对常量的引用  cont int &ref = var; 不能通过引用修改被引用对象的值
 *             const int i = 10; int &a = i; //错误
 *             const int i = 10; const int &a = i; //正确
 *             int i = 10;  int &a = i; //正确
 *             大部分情况下，引用的类型要和与之绑定的对象严格匹配,但是有两个例外
 *             1. 初始化常量引用时允许使用任意表达式作为初始化值，只要表达式结果能转换成引用的类型
 *             int i = 42;
 *             const int &r1 = i;      // we can bind a const int& to a plain int object
 *             const int &r2 = 42;     // ok: r1 is a reference to const
 *             const int &r3 = r1 * 2;     // ok: r3 is a reference to const
 *             int &r4 = r * 2;        // error: r4 is a plain, non const reference
 *       6.4 指向常量的指针
 *           const double pi = 3.14;
 *           const double *cptr = &pi; // 指针指向的值不能通过指针修改      
 *           指针的类型必须与所指常亮的类型一直但是有两个例外，
 *           double d = 3.14; 
 *           cptr = &d; // 指向常量的指针可以指向非常量对象，指向常量的指针仅仅要求不能通过该指针改变对象的值0
 *       6.5 常量指针
 *           指针是对象所以可以用const 修饰 int *const curErr = &b; // 指针是一个常量，不能改变指向；但是可以改变值
 *           根据这个特点常量指针只可以指向常量类型
 *       6.6 指针本身是一个对象，它又可以指向另外一个对象，所以它本身是不是一个常量以及所指的对象是不是常量是两个独立的概念
 *           用顶层const表示指针本身是个常亮，用底层const表示指针所指对象是个常量
 *       6.7 constexpt 常量表达式 是指值不会改变并且在编译过程中就得到计算结果的表达式。字面值属于常量表达式、字面值初始化的const对象也是常量表达式
 *           常量表达式难以分辨c++11 用constexpr 关键字让编译器来判断
 *           constexpt int mf = 20; // 20 是常量表达式
 *       6.8 constexpr和指针 
 *           const int *p = nullptr;          // p是指向常量的指针
 *           constexpr int *q = nullptr;     //q是一个指针常量
 * 7. 类型别名
 *    typdef 类型名 类型别名
 *    using 类型别名 = 原类型 c++11新标准
 * 8. auto类型自动推导
 *           
 * 9. decltype类型指示符
 * 10 编写自己的头文件   
 * 
 *           
 * 
 */
#define day 7
int main()
{
    //--------------------黑马程序员-------------------------
    // 1.
    cout << "define 常量 ---" << day << endl;
    const int cconst = 1;
    cout << "const 常量---" << cconst << endl;
    // 2.
    cout << "sizeOf---long " << sizeof(long) << endl;
    cout << "sizeOf---long long " << sizeof(long long) << endl;
    cout << "sizeOf---int变量 " << sizeof(cconst) << endl;
    // 2.3
    cout << "科学计数法---" << 2e2 << endl;  // e * 10 ^ 2
    cout << "科学计数法---" << 2e-2 << endl; // e * 0.1 ^ 2
    // 2.4
    char ch = 97;
    cout << "直接用ASCII码给字符型变量赋值---" << ch << endl;
    // 2.6
    char str1[] = "hello world"; // C风格要用 双引号括起来
    // strcpy(str1,"你是知道的12345678909876543210123456789");//"C:\\Program Files\\mingw64\\bin\\gdb.exe",可以通过编译其他不行
    // printf("C风格字符串1---%s\n",str1);
    cout << "C风格字符串1---" << str1 << endl;
    //  char* str2 = "char* str2";//它表示在试图将一个字符串常量转换为char*类型的指针时发生了错误,可以使用const char*类型的指针来指向字符串常量
    const char *str2 = "char* str2"; //
    cout << "C风格字符串2---" << str2 << endl;
    printf("C风格字符串str1长度%d\n", strlen(str1));
    printf("C风格字符串str2长度%d\n", strlen(str2));
    string str = "hello world";
    cout << "C++风格字符串---" << str << endl;
    // 2.8
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    cout << "整个数组所占内存空间为： " << sizeof(arr) << endl;
    cout << "每个元素所占内存空间为： " << sizeof(arr[0]) << endl;
    cout << "数组的元素个数为： " << sizeof(arr) / sizeof(arr[0]) << endl;
    // 、可以通过数组名获取到数组首地址
    // printf("数组首地址为：%d\n", arr);
    cout << "数组首地址为：" << (uintptr_t)arr << endl;
    cout << "数组中第一个元素地址为： " << (long long)&arr[0] << endl;
    cout << "数组中第二个元素地址为： " << (long long)&arr[1] << endl;
    // 2.9 二维数组
    int arr1[2][3] = {{1, 2, 3}, {4, 5, 6}};
    cout << "二维数组大小： " << sizeof(arr1) << endl;
    cout << "二维数组一行大小： " << sizeof(arr1[0]) << endl;
    cout << "二维数组元素大小： " << sizeof(arr1[0][0]) << endl;
    cout << "二维数组行数： " << sizeof(arr1) / sizeof(arr1[0]) << endl;
    cout << "二维数组列数： " << sizeof(arr1[0]) / sizeof(arr1[0][0]) << endl;
    // 地址
    cout << "二维数组首地址：" << arr1 << endl;
    cout << "二维数组第一行地址：" << arr1[0] << endl;
    cout << "二维数组第二行地址：" << arr1[1] << endl;
    cout << "二维数组第一个元素地址：" << &arr1[0][0] << endl;
    cout << "二维数组第二个元素地址：" << &arr1[0][1] << endl;

    // 引用-------------------------------------------------------------
    int a = 1;  // 与a相比下面 两个变量属于复合类型（类就修饰符+变量名）
    int &n = a; // 给a取一个别名（&属于声明的一部分 int &）(类型修饰符 * &)
    // cout << "a的别名&n=" << n << endl;
    cout << "调用别名 n = " << n << endl;
    // int &m;   //报错，别名必须在定义时初始化
    int *p = &a; // 指针（*属于声明的一部分 int &）(类型修饰符 * &)
    int *&r = p; // 指向指针的引用 从右向左读，有助于理解这个复杂的类型

    int &&x = 5; // 上面都是左值引用现在是右值引用, int &x=5 不允许这样做，所以就有了 int &&x = 5
    cout << "右值引用" << x << endl;
    // // const---------------------------------------------------------------
    int b = 10;
    const int &c = b; // 对常量的引用，不能修改引用变量的值
    const int &d = c * 2;
    // int &e = c * 2; //报错 如果引用右侧是一个表达式，就会创建一个临时变量，
    // 实际上是&e = temp，引用目的是为了改变被引用对象的值，但temp对应一个表达式，此时引用的目的消失了，所以C++不允许这种操作
    const double pi = 3.14;
    // double *p = &pi;//错误，p是一个普通指针
    // const double *p = &pi; //指针常量才能指向常量， *p 不能赋值 但是可以指向另一个 变量
    p = &b; // 指针常量指向另一个变量

    int *const curErr = &b; // 指针是一个常量，不能改变指向；
    *curErr = 10;           // 但是能改变值

    const int max = 20; // 常量表达式，由数据类型和初始值（编译时段就能确定）共同决定
    // const int temp = getSize()//不是一个常量表达式，因为初始值要到运行时段才能确定
    int min = 10;          // 不是常量表达式，数据类型不是const
    constexpr int mf = 20; // C++ 11新标准  constexpr 方便编译器检验是否是一个常量表达式
    // constexpr int mf = getSize(); //如果getSize()是一个常量函数，那它就是一个常量表达式
    const int *pp = nullptr; // nullptr是c++中空指针类型的关键字

    //4.4
    unsigned char uc = -1; // 256%(255+1)=0
    cout<<"uc = " << (int)uc << endl;
    
    return 0;
}