#include <stdio.h>
#include <unistd.h>
/**
 * 信号
 * 信号的结构简单不能携带大量信息，满足条件才能发送，在系统中优先级非常高。信号是软件层面的中断，无论进程运行到什么位置都必须停止运行处理信号
 * 所有信号的产生和处理都是内核负责
 * 1.信号产生： 
 * 键盘操作产生信号：用户按下Ctrl-C，这个键盘输入产生一个硬件中断
 * 命令产生信号：通过kill命令终止某一个进程
 * 系统调用：如果CPU当前正在执行这个进程的代码调用，比如函数 sleep()，进程收到相关的信号，被迫挂起
 * 硬件异常：正在运行的程序访问了非法内存，发生段错误，进程退出。
 * kill -l 命令可以察看系统定义的信号列表:1-31是常规信号，
 * 信号四要素，编号、名称、事件、默认处理动作
 * SIGABRT      6      Core    Abort signal from abort(3) man 7 signal 有的信号会有很多值，这是因为不同操作系统信号值会不一样
 * 在终端中 Ctrl+c--->2SIGINT 中断 Ctrl+z--->20SIGTSTP 暂停 CTRL+\ --->3SIGQUIT 退出
 * kill 信号值 进程号  对进程发命令  奇怪的是发送11段错误 msys2终端会退出 不管发什么都会退出

 * Linux 内核的进程控制块 PCB是一个结构体，task_struct,除了包含进程id，状态，工作目录，用户id，组id,文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。
 * 阻塞信号集：将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后)
 * 未决信号集:是一个用来存储已经到达但由于某些原因而被延迟处理的信号的集合。当一个信号到达时，如果该信号没有被阻塞，它就会被添加到未决信号集中，然后等待进程处理
 * 2.未决
 *   信号产生了, 但是这个信号还没有被处理掉, 这个期间信号的状态称之为未决状态
 * 3.递达
 *   信号被处理了(被某个进程处理掉) 
 * 4.kill
 *   kill作用是发送信号给进程
 *   kill 命令 kill 信号值 进程号
 *   kill 函数 kill(进程号,信号宏)
 * 5.alarm函数
 *   在指定的秒数后 内核会给进程发送SIGALRM信号，进程收到信号后默认动作终止，每个进程都有且只有一个定时器
 *   返回值是上一次闹钟剩余时间,如果没有上一次就返回0。
 *   unsigned int alarm(unsigned int seconds);
 *   time ./signal  可以得到 运行时间
 *   real	0m1.003s 程序执行时间
 *   user	0m0.004s 程序运行在用户空间消耗时间
 *   sys	0m1.006s 程序运行在用户内核消耗时间     老师说 real>user+sys 因为要等待设备，。为什么我这个例子不是呢？？？
 * 6.setitimer 比alarm更精细
 *
*/
int main(){
    //5. alarm函数
    int t = alarm(3);
    printf("剩余时间---%d\n",t);
    while (1)
    {
        /* code */
    }
    perror("信号---");//接收到闹钟终止信号，这句不会走
    return 1;
}